<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <style>
<!--

body { background-color: darkgrey; color: #333; }
body { font-family: Verdana, Arial, Helvetica, sans-serif; line-height: 1.3em; font-size: 10;}
th { font-size: 70%; border: 1px solid #999; border-width: 1px 0 1px 0; vertical-align: top; white-space: nowrap; }
td { font-size: 70%; border: 1px solid #999; border-width: 1px 0 1px 0; vertical-align: top; white-space: nowrap; }

div#div_wyswyg { background-color: lightgrey; color: #333; }
div#div_editor { background-color: white; color: #333; }


div#div_MarkupHelp { background-color: darkgrey; }
div#div_MarkupHelp table { margin-bottom: 0; border-top: 3px solid #999; border-left: 3px solid #999; border-right: 3px solid #BBB; border-bottom: 3px solid #BBB}
div#div_MarkupHelp td { font-size: 80%; padding: 0.2em; margin: 0; border: 1px solid #999; border-width: 1px 0 1px 0; vertical-align: top; white-space: nowrap; }
div#div_MarkupHelp td.arrow { padding-right: 5px; padding: 0 0.75em; color: #999; }
div#div_MarkupHelp h3 { font-size: 90%; font-weight: bold; margin: 0 0 5px 0; padding: 5px 0 0 0; }
div#div_MarkupHelp p { font-size: 70%; }
-->
    </style>
    <script type="text/javascript">
/*
 * JavaScript Creole 1.0 Wiki Markup Parser
 *
 * Copyright (c) 2009 Ivan Fomichev
 *
 * Portions Copyright (c) 2007 Chris Purcell
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Packages anlegen
 */
if (!Parse) { 
    var Parse = {}; 
}
if (!Parse.Simple) {
    Parse.Simple = {}; 
}


/**
 * <h1>FeatureDomain:</h1>
 *      WebApp
 * <h1>FeatureDescription:</h1>
 *     erzeugt ein Parse.Simple.Base
 * <h1>FeatureConditions:</h1>
 *     XXXX
 * <h1>FeatureResult:</h1>
 *     updates memberVariable this.grammar
 *     updates memberVariable this.grammar.root with aid of this.ruleConstructor
 *     updates memberVariable options
 * <h1>FeatureKeywords:</h1>
 *     BusinessLogic WebLayout
 * @constructor
 * @param grammar
 * @param options
 * @returns {Parse.Simple.Base}
 */
Parse.Simple.Base = function(grammar, options) {
    if (!arguments.length) { return; }

    this.grammar = grammar;
    this.grammar.root = new this.ruleConstructor(this.grammar.root);
    this.options = options;
};

/**
 * Klassendefinition
 */
Parse.Simple.Base.prototype = {
    ruleConstructor: null,
    grammar: null,
    options: null,

    /**
     * <h1>FeatureDomain:</h1>
     *      WebApp - WebLayout
     * <h1>FeatureDescription:</h1>
     *     parst "data" und haengt die erzeugten HTMElemente Elemente an node an
     * <h1>FeatureConditions:</h1>
     *     XXXX
     * <h1>FeatureResult:</h1>
     *     updates paramVariable node with result of this.grammar.root.apply
     * <h1>FeatureKeywords:</h1>
     *     BusinessLogic WebLayout
     * @param HTMLElement node - Ziel-Element an welches die aus data erzeugten Elemente angehangen werden
     * @param String data - zu parsender Text
     * @param options
     */
    parse: function(node, data, options) {
        if (options) {
            for (i in this.options) {
                if (typeof options[i] == 'undefined') { options[i] = this.options[i]; }
            }
        }
        else {
            options = this.options;
        }
        // Win-Zeilenumbrueche durch Linux ersetzen
        data = data.replace(/\r\n?/g, '\n');
        
        // data parsen und Eelembte an node anhaengen
        this.grammar.root.apply(node, data, options);
        
        // Replace fuer IE
        if (options && options.forIE) { node.innerHTML = node.innerHTML.replace(/\r?\n/g, '\r\n'); }
    }
};
Parse.Simple.Base.prototype.constructor = Parse.Simple.Base;

/**
 * <h1>FeatureDomain:</h1>
 *      WebLayout
 * <h1>FeatureDescription:</h1>
 *     XXXX
 * <h1>FeatureConditions:</h1>
 *     XXXX
 * <h1>FeatureResult:</h1>
 *     updates memberVariable this[p]
 *     updates memberVariable this.children
 * <h1>FeatureKeywords:</h1>
 *     BusinessLogic WebLayout
 * @constructor
 * @param params
 * @returns {Parse.Simple.Base.Rule}
 */
Parse.Simple.Base.Rule = function(params) {
    if (!arguments.length) { return; }

    // Parameter kopieren
    for (var p in params) { this[p] = params[p]; }
    
    // Kindelente initialisieren
    if (!this.children) { this.children = []; }
};
Parse.Simple.Base.prototype.ruleConstructor = Parse.Simple.Base.Rule;

/**
 * Klassendefinition
 */
Parse.Simple.Base.Rule.prototype = {
//    /*
//     * RegEx die zum Suchen ausgefuehrt word
//     */
    regex: null,
    
//    /*
//     * Anzahl der 
//     */
    capture: null,
//    /*
//     * RegEx um Elemente im gefunden Sztring zu ersetzen
//     */
    replaceRegex: null,
//    /*
//     * String der bei replaceRegex eingesetzt wird
//     */
    replaceString: null,
//    /*
//     * Html-Tag der um inneren Text erzeugt wird
//     */
    tag: null,
    attrs: null,
    children: null,

    /**
     * <h1>FeatureDomain:</h1>
     *      WebLayout
     * <h1>FeatureDescription:</h1>
     *     sucht in data nach der RegEx und liefert Array mit den treffern zurueck
     * <h1>FeatureConditions:</h1>
     *     XXXX
     * <h1>FeatureResult:</h1>
     *     returnValue Array of String NotNull - Liste der Suchtreffer
     * <h1>FeatureKeywords:</h1>
     *     BusinessLogic WebLayout
     * @param String data - zu parsender Text
     * @param options
     * @returns Array
     */
    match: function(data, options) {
        return data.match(this.regex);
    },

    /**
     * <h1>FeatureDomain:</h1>
     *      WebLayout
     * <h1>FeatureDescription:</h1>
     *     sucht in data nach der RegEx und liefert Array mit den treffern zurueck
     * <h1>FeatureConditions:</h1>
     *     XXXX
     * <h1>FeatureResult:</h1>
     *     returnValue Parse.Simple.Base.Rule NotNull - das aktuelle RuleObject
     * <h1>FeatureKeywords:</h1>
     *     BusinessLogic WebLayout
     * @param HTMLElement node - aktuelles Baiss-Element an welches RuleResult angehangen wird
     * @param Array r - Liste der Suchtreffer fur die Regel
     * @param options
     * @returns {Parse.Simple.Base.Rule}
     */
    build: function(node, r, options) {
        // falls Regel matcht, Matchresult in data speichetrn
        var data = null;
        if (this.capture !== null) {
            data = r[this.capture];
        }

        var target;
        // falls Rule eigenen Tag hat: diesen an Node anlegen und als Ziel benutzen
        if (this.tag) {
            target = document.createElement(this.tag);
            node.appendChild(target);
        } else {
            // wenn keinen eigenen Tag: Node als Ziel benutzen
            target = node; 
         }

        if (data) {
            // falls ReplaceRegEx definiert: auf MacthResult anwenden 
            if (this.replaceRegex) {
                data = data.replace(this.replaceRegex, this.replaceString);
            }
            // MatchResult an Target anhaengen
            this.apply(target, data, options);
        }

        // falls Rule eigene Atribute hat, diese auf TargetElement anwenden
        if (this.attrs) {
            for (var i in this.attrs) {
                target.setAttribute(i, this.attrs[i]);
                if (options && options.forIE && i == 'class') { 
                    target.className = this.attrs[i]; 
                }
            }
        }
        return this;
    },

    /**
     * <h1>FeatureDomain:</h1>
     *      WebApp - WebLayout
     * <h1>FeatureDescription:</h1>
     *     parst "data" und haengt die erzeugten HTMElemente Elemente an node an
     * <h1>FeatureConditions:</h1>
     *     XXXX
     * <h1>FeatureResult:</h1>
     *     updates paramVariable node with result of this.grammar.root.apply
     *     returnValue Parse.Simple.Base.Rule NotNull - das aktuelle RuleObject
     * <h1>FeatureKeywords:</h1>
     *     BusinessLogic WebLayout
     * @param HTMLElement node - Ziel-Element an welches die aus data erzeugten Elemente angehangen werden
     * @param String data - zu parsender Text
     * @param options
     * @returns {Parse.Simple.Base.Rule}
     */
    apply: function(node, data, options) {
        // belegt zu parsenden String
        var tail = '' + data;
        console.log("apply: start this.tag:" + this.tag + " tail:" + tail);
        
        // Macthes der Kindsregeln
        var matches = [];

        // erzeugt ggf. Fallback-Object (falls noch nicht belegt, mit sich selbst, ohne Kinder !!!)
        if (!this.fallback.apply) {
            this.fallback = new this.constructor(this.fallback);
        }

        // Endlosschleife: bis etwas gefunden ist
        while (true) {
            // Besten Fund und zugehoerige Regel zuruecksetzen
            var best = false;
            var rule  = false;
            
            // alle Kinds-Regeln durchlaufen
            for (var i = 0; i < this.children.length; i++) {
                // falls keine eigenen Matches: ggf die der KindsRegeln ranziehen
                if (typeof matches[i] == 'undefined') {
                    // falls Kindselement nicht matcht: neu intialisieren
                    if (!this.children[i].match) {
                        this.children[i] = new this.constructor(this.children[i]);
                    }
                    
                    // Matches fuer die KindsRegel belegen
                    matches[i] = this.children[i].match(tail, options);
                }
                
                // falls Matches der Kindsregel belegt und besser als "best" 
                // dann Besten Fund und zugehoerige Regel mit Kinds-Element belegen 
                if (matches[i] && (!best || best.index > matches[i].index)) {
                    best = matches[i];
                    rule = this.children[i];
                    
                    // falls wir am String-Anfang sind: Schleife abbrechen, besser gehts nicht 
                    if (best.index == 0) {
                        break; 
                    }
                }
            }

            // falls Besten Fund: meine eigene Regel auf den String davor anwenden 
            var pos = best ? best.index : tail.length;
            if (pos > 0) {
                this.fallback.apply(node, tail.substring(0, pos), options);
            }

            // falls keinen Besten Fund: Schleife abbrechen 
            if (!best) { 
                break; 
            }

            // falls beste Rule keine build-Funktion hat: neues Rule-Object 
            // ueber Standard-Konstruktor mit Build-Funktion  
            if (!rule.build) { 
                rule = new this.constructor(rule); 
            }
            
            // Build-Funktion zum erzeugen des HTML anwenden
            rule.build(node, best, options);
            
            console.log("apply: run build this.tag:" + this.tag + " rule.tag:" + rule.tag + " best:" + best);

            // 
            var chopped = best.index + best[0].length;
            tail = tail.substring(chopped);
            for (var i = 0; i < this.children.length; i++) {
                if (matches[i]) {
                    if (matches[i].index >= chopped) {
                        matches[i].index -= chopped;
                    }
                    else {
                        matches[i] = void 0;
                    }
                }
            }
        }

        return this;
    },

    fallback: {
        apply: function(node, data, options) {
            if (options && options.forIE) {
                // workaround for bad IE
                data = data.replace(/\n/g, ' \r');
            }
            node.appendChild(document.createTextNode(data));
        }
    }    
};

Parse.Simple.Base.Rule.prototype.constructor = Parse.Simple.Base.Rule;

Parse.Simple.Creole = function(options) {
    // StandardRegEx initialisieren /Img...)
    var rx = {};
    rx.link = '[^\\]|~\\n]*(?:(?:\\](?!\\])|~.)[^\\]|~\\n]*)*';
    rx.linkText = '[^\\]~\\n]*(?:(?:\\](?!\\])|~.)[^\\]~\\n]*)*';
    rx.uriPrefix = '\\b(?:(?:https?|ftp)://|mailto:)';
    rx.uri = rx.uriPrefix + rx.link;
    rx.rawUri = rx.uriPrefix + '\\S*[^\\s!"\',.:;?]';
    rx.interwikiPrefix = '[\\w.]+:';
    rx.interwikiLink = rx.interwikiPrefix + rx.link;
    rx.img = '\\{\\{((?!\\{)[^|}\\n]*(?:}(?!})[^|}\\n]*)*)' 
           + (options && options.strict ? '' : '(?:') 
           + '\\|([^}~\\n]*((}(?!})|~.)[^}~\\n]*)*)' 
           + (options && options.strict ? '' : ')?') 
           + '}}';

    // Funktion zum Formatieren von Links 
    var formatLink = function(link, format) {
        if (format instanceof Function) {
            return format(link);
        }

        format = format instanceof Array ? format : [ format ];
        if (typeof format[1] == 'undefined') { format[1] = ''; }
        return format[0] + link + format[1];
    };

    // Gramattik-regeln initialisieren
    var g = {
        hr: { 
            tag: 'hr', 
            regex: /(^|\n)\s*----\s*(\n|$)/ 
        },

        br: { 
            tag: 'br', 
            regex: /\\\\/ 
        },

        // Vorformatiert
        preBlock: { 
            tag: 'pre3', 
            capture: 2,
            regex: /(^|\n)\{\{\{\n((.*\n)*?)\}\}\}(\n|$)/,
            replaceRegex: /^ ([ \t]*\}\}\})/gm,
            replaceString: '$1' 
        },
        preBlock2: { 
            tag: 'pre', 
            capture: 2,
            regex: /(^|\n)__((.*\n)*?)__/,
            replaceRegex: /^ ([ \t]*\}\}\})/gm,
            replaceString: '$1' 
        },

        tt: { 
            tag: 'tt',
            regex: /\{\{\{(.*?\}\}\}+)/, 
            capture: 1,
            replaceRegex: /\}\}\}$/, 
            replaceString: '' 
        },

        ulist: { 
            tag: 'ul', 
            capture: 0,
            //regex: /(^|\n)([ \t]*\*[^*#].*(\n|$)([ \t]*[^\s*#].*(\n|$))*([ \t]*[*#]{2}.*(\n|$))*)+/ 
            //      (    )(               (    )(               (    )) (               (    )) )
            // Einsatz verbatim (__((.*\n)*?)__)*
            regex: /(^|\n)([ \t]*\*[^*#].*(\n|$)([ \t]*[^\s*#].*(\n|$))*([ \t]*[*#]{2}.*(\n|$))*(__((.*\n)*?)__)*)+/ 
        },
        olist: { 
            tag: 'ol', 
            capture: 0,
            regex: /(^|\n)([ \t]*#[^*#].*(\n|$)([ \t]*[^\s*#].*(\n|$))*([ \t]*[*#]{2}.*(\n|$))*)+/ 
        },
        li: { 
            tag: 'li', 
            capture: 0,
            // regex: /[ \t]*([*#]).+(\n[ \t]*[^*#\s].*)*(\n[ \t]*\1[*#].+)*/,
            // verbatim: (__((.*\n)*?)__)*
            //            (    )  (                 ) (                )
            regex: /[ \t]*([*#]).+(\n[ \t]*[^*#\s].*)*(\n[ \t]*\1[*#].+)*(__((.*\n)*?)__)*/,
            replaceRegex: /(^|\n)[ \t]*[*#]/g, 
            replaceString: '$1' 
        },

        table: { 
            tag: 'table', 
            capture: 0,
            regex: /(^|\n)(\|.*?[ \t]*(\n|$))+/ 
        },
        tr: { 
            tag: 'tr', 
            capture: 2, 
            regex: /(^|\n)(\|.*?)\|?[ \t]*(\n|$)/ 
        },
        th: { 
            tag: 'th', 
            regex: /\|+=([^|]*)/, 
            capture: 1 
        },
        td: { 
            tag: 'td', 
            capture: 1,
            regex: '\\|+([^|~\\[{]*((~(.|(?=\\n)|$)|' 
                +  '\\[\\[' + rx.link + '(\\|' + rx.linkText + ')?\\]\\]' 
                +  (options && options.strict ? '' : '|' + rx.img) 
                +  '|[\\[{])[^|~]*)*)' 
        },

        singleLine: { 
            regex: /.+/, 
            capture: 0 
        },
        paragraph: { 
            tag: 'p', 
            capture: 0,
            regex: /(^|\n)([ \t]*\S.*(\n|$))+/ 
        },
        text: { 
            capture: 0, 
            regex: /(^|\n)([ \t]*[^\s].*(\n|$))+/ 
        },

        strong: { 
            tag: 'strong', 
            capture: 1,
            regex: /\*\*([^*~]*((\*(?!\*)|~(.|(?=\n)|$))[^*~]*)*)(\*\*|\n|$)/ 
        },
        em: { 
            tag: 'em', 
            capture: 1,
            regex: '\\/\\/(((?!' + rx.uriPrefix + ')[^\\/~])*' 
            + '((' + rx.rawUri + '|\\/(?!\\/)|~(.|(?=\\n)|$))' 
            + '((?!' + rx.uriPrefix + ')[^\\/~])*)*)(\\/\\/|\\n|$)' 
        },

        img: { 
            regex: rx.img,
            build: function(node, r, options) {
                var img = document.createElement('img');
                img.src = r[1];
                img.alt = r[2] === undefined
                ? (options && options.defaultImageText ? options.defaultImageText : '')
                        : r[2].replace(/~(.)/g, '$1');
                node.appendChild(img);
            } 
        },

        namedUri: { 
            regex: '\\[\\[(' + rx.uri + ')\\|(' + rx.linkText + ')\\]\\]',
            build: function(node, r, options) {
                var link = document.createElement('a');
                link.href = r[1];
                if (options && options.isPlainUri) {
                    link.appendChild(document.createTextNode(r[2]));
                }
                else {
                    this.apply(link, r[2], options);
                }
                node.appendChild(link);
            } 
        },

        namedLink: { 
            regex: '\\[\\[(' + rx.link + ')\\|(' + rx.linkText + ')\\]\\]',
            build: function(node, r, options) {
                var link = document.createElement('a');

                link.href = options && options.linkFormat
                ? formatLink(r[1].replace(/~(.)/g, '$1'), options.linkFormat)
                        : r[1].replace(/~(.)/g, '$1');
                this.apply(link, r[2], options);

                node.appendChild(link);
            } 
        },

        unnamedUri: { 
            regex: '\\[\\[(' + rx.uri + ')\\]\\]',
            build: 'dummy' 
        },
        unnamedLink: { 
            regex: '\\[\\[(' + rx.link + ')\\]\\]',
            build: 'dummy' 
        },
        unnamedInterwikiLink: { 
            regex: '\\[\\[(' + rx.interwikiLink + ')\\]\\]',
            build: 'dummy' 
        },

        rawUri: { 
            regex: '(' + rx.rawUri + ')',
            build: 'dummy' 
        },

        escapedSequence: { 
            regex: '~(' + rx.rawUri + '|.)', 
            capture: 1,
            tag: 'span', 
            attrs: { 'class': 'escaped' } 
        },
        escapedSymbol: { 
            regex: /~(.)/, 
            capture: 1,
            tag: 'span', 
            attrs: { 'class': 'escaped' } 
        }
    };

    // spezielle Build-Regeln anpassen
    g.unnamedUri.build = g.rawUri.build = function(node, r, options) {
        if (!options) { options = {}; }
        options.isPlainUri = true;
        g.namedUri.build.call(this, node, Array(r[0], r[1], r[1]), options);
    };
    g.unnamedLink.build = function(node, r, options) {
        g.namedLink.build.call(this, node, Array(r[0], r[1], r[1]), options);
    };
    g.namedInterwikiLink = { 
        regex: '\\[\\[(' + rx.interwikiLink + ')\\|(' + rx.linkText + ')\\]\\]',
        build: function(node, r, options) {
            var link = document.createElement('a');

            var m, f;
            if (options && options.interwiki) {
                m = r[1].match(/(.*?):(.*)/);
                f = options.interwiki[m[1]];
            }

            if (typeof f == 'undefined') {
                if (!g.namedLink.apply) {
                    g.namedLink = new this.constructor(g.namedLink);
                }
                return g.namedLink.build.call(g.namedLink, node, r, options);
            }

            link.href = formatLink(m[2].replace(/~(.)/g, '$1'), f);

            this.apply(link, r[2], options);

            node.appendChild(link);
        }
    };
    g.unnamedInterwikiLink.build = function(node, r, options) {
        g.namedInterwikiLink.build.call(this, node, Array(r[0], r[1], r[1]), options);
    };
    
    // Link-Grammatik: moegliche SubElemente (auch rekursiv) zuordnen z.B a: img
    g.namedUri.children = g.unnamedUri.children = g.rawUri.children =
        g.namedLink.children = g.unnamedLink.children =
            g.namedInterwikiLink.children = g.unnamedInterwikiLink.children =
                [ g.escapedSymbol, g.img ];

    
    // Grammatik fuer Ueberschriften initialisieren
    for (var i = 1; i <= 6; i++) {
        g['h' + i] = { 
                tag: 'h' + i, 
                capture: 2,
                regex: '(^|\\n)[ \\t]*={' + i + '}[ \\t]' 
                     + '([^~]*?(~(.|(?=\\n)|$))*)[ \\t]*=*\\s*(\\n|$)'
        };
    }

    // Listen-Grammatik: moegliche SubElemente (auch rekursiv) zuordnen z.B ul: li: ol: li
    g.ulist.children = g.olist.children = [ g.li ];
    g.li.children = [ g.ulist, g.olist, g.preBlock2];
    g.li.fallback = g.text;

    // Table-Grammatik: moegliche SubElemente zuordnen z.B table: tr: td
    g.table.children = [ g.tr ];
    g.tr.children = [ g.th, g.td ];
    g.td.children = [ g.singleLine ];
    g.th.children = [ g.singleLine ];

    // Ueberschriften-Grammatik: moegliche SubElemente (auch rekursiv) zuordnen z.B. h1: ul a img...
    g.h1.children = g.h2.children = g.h3.children =
        g.h4.children = g.h5.children = g.h6.children =
            g.singleLine.children = g.paragraph.children =
                g.text.children = g.strong.children = g.em.children =
                    [ g.escapedSequence, g.strong, g.em, g.br, g.rawUri,
                      g.namedUri, g.namedInterwikiLink, g.namedLink,
                      g.unnamedUri, g.unnamedInterwikiLink, g.unnamedLink,
                      g.tt, g.img, g.preBlock2 ];

    g.root = {
            children: [ g.h1, g.h2, g.h3, g.h4, g.h5, g.h6,
                        g.hr, g.ulist, g.olist, g.preBlock, g.preBlock2, g.table],
                        fallback: { children: [ g.paragraph ] }
    };

    Parse.Simple.Base.call(this, g, options);
};

Parse.Simple.Creole.prototype = new Parse.Simple.Base();

Parse.Simple.Creole.prototype.constructor = Parse.Simple.Creole;

    </script>
    <script type="text/javascript">
function $(id) {
    return document.getElementById(id);
}

window.onload = function() {
    var input = $('textarea_editor');
    var wyswyg = $('div_wyswyg');
    var creole = new Parse.Simple.Creole( {
        forIE: document.all,
        interwiki: {
            WikiCreole: 'http://www.wikicreole.org/wiki/',
            Wikipedia: 'http://en.wikipedia.org/wiki/'
        },
        linkFormat: ''
    } );

    var render = function() {
        wyswyg.innerHTML = '';
        creole.parse(wyswyg, input.value);
    };

    input.onkeyup = function() {
        render();
    };

    render();
}


function saveAs(){
    var sMarkup =  document.getElementsByTagName("html")[0].innerHTML; 
    var uriContent = "data:application/octet-stream," + encodeURIComponent(sMarkup);
    var newWindow = window.open(uriContent, 'neuesDokument');
}
    
    </script>
</head>
<body>
    <div id="div_full" style="width: 100%">
    <a href="#" onclick="javascript:document.getElementById('div_editor').style.display='none'; document.getElementById('div_wyswyg').style.cssFloat='left'; document.getElementById('div_wyswyg').style.width='700px';">Druckversion</a>
    <a href="#" onclick="javascript:document.getElementById('div_editor').style.display='block'; document.getElementById('div_wyswyg').style.width='48%'; document.getElementById('div_wyswyg').style.cssFloat='right';">Normalversion</a>
    Version: $Id: projektplan-header.html,v 1.2 2013/11/16 10:20:56 micha Exp $
    <br>
    <div id="div_editor" style="width: 48%; float:left;">
            <form>
                <textarea id="textarea_editor" style="width: 100%;" rows="30" spellcheck="true">
* OFFEN - Urlaube                                                                                                                                                [NodeMeta: Urlaube,85,,] [NodeSys: DT201405051805384241,05.05.2014 18:05,F1E93425E9C1AF2CA96788E280FC56F3,05.05.2014 18:05,1]
** **OFFEN - 2014**                                                                                                                                              [NodeMeta: Urlaube,86,,] [NodeSys: DT201405051805384242,05.05.2014 18:05,49A92CD348F8CAADFB9C619A0BDFB81E,05.05.2014 18:05,1]
*** **OFFEN - Pfingsturlaub**                                                                                                                                    [NodeMeta: Urlaube,87,,] [NodeSys: DT201405051805384403,05.05.2014 18:05,A95F61849A5C04719D81AEF0E010E7C5,05.05.2014 18:05,1]
**** OFFEN - Grobplanung                                                                                                                                         [NodeMeta: Urlaube,88,,] [NodeSys: DT201405051805384404,05.05.2014 18:05,91A159808BE1F59278B757A66603AF34,05.05.2014 18:05,1]

            </textarea>
            </form>
            <br>
            <div id="div_MarkupHelp" style="width: 100%;">
                <h3>WikiCreole-Spickzettel</h3>
                <table style="width: 100%;" border="1" cellpadding="0" cellspacing="0">
                <tbody>
                    <tr><td>//kursiv//</td><td class="arrow">&#8594;</td><td><em>kursiv</em></td></tr>
                    <tr><td>**fett**</td><td class="arrow">&#8594;</td><td><strong>fett</strong></td></tr>
                    <tr><td>* Liste<br>* Zweiter Punkt<br>** Unterpunkt</td><td class="arrow">&#8594;</td><td>&#8226; Liste<br>&#8226; Zweiter Punkt<br>..&#8226; Unterpunkt</td></tr>
                    <tr><td># Num. Liste<br># Zweiter Punkt<br>## Unterpunkt</td><td class="arrow">&#8594;</td><td>1. Num. Liste<br>2. Zweiter Punkt<br>2.1 Unterpunkt</td></tr>
                    <tr><td>Link zu [[Seite]]</td><td class="arrow">&#8594;</td><td>Link zu <a href="http://www.wikicreole.org/attach/CheatSheet/URL">Seite</a></td></tr>
                    <tr><td>[[URL|Linktitel]]</td><td class="arrow">&#8594;</td><td><a href="http://www.wikicreole.org/attach/CheatSheet/URL">LinkTitel</a></td></tr>
                    <tr><td>== Gro√&#376;e √&#339;ber.<br>=== Mittlere √&#339;ber.<br>==== Kleine √&#339;ber.</td><td class="arrow">&#8594;</td><td><span style="font-size: 130%; font-weight: bold;"> Gro√&#376;e √&#339;ber.</span><br><span style="font-size: 115%; font-weight: bold;">Mittlere √&#339;ber.</span><br><span style="font-size: 100%; font-weight: bold;">Kleine √&#339;ber.</span></td></tr>
                    <tr><td>Kein<br> Zeilenumbruch!<br><br>Benutze Leerzeile</td><td class="arrow">&#8594;</td><td>Kein Umbruch!<br><br>Benutze Leerzeile</td></tr>
                    <tr><td>Umbruch\\Manuell<br></td><td class="arrow">&#8594;</td><td>Umbruch<br>Manuell</td></tr>  
                    <tr><td>Horizontale Linie:<br>----</td><td class="arrow">&#8594;</td><td>Horizontale Linie: <hr></td></tr>
                    <tr><td>{{Bild.jpg|titel}}</td><td class="arrow">&#8594;</td><td>Bild mit Titel</td></tr>
                    <tr><td>|=|=Tab|=√&#339;ber.|<br>|A|Tabelle|Zeile|<br>|B|Tabelle|Zeile|</td><td class="arrow">&#8594;</td><td>Tabelle</td></tr>
                    <tr><td>{{{<br>== [[Nowiki]]:<br>**unformatiert**<br>}}}</td><td class="arrow">&#8594;</td><td>== [[Nowiki]]:<br>**unformatiert**</td></tr>
                </tbody>
                </table>
                <b style="font-size: 70%;">www.wikicreole.org</b>
            </div>
        </div>    
        <div id="div_wyswyg" style="width: 48%; float:right;"> </div>
    </div>


</body></html>
